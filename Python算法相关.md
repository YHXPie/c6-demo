_必修一  程序设计语言_
## Python 算法相关
所有内容均来源自《必修一 数据与计算知识点刚要》，仅用作整理用途。如果你不想看那本纲要知识点，欢迎浏览或者打印本页。

!> **注意：在 Python 中，所有的符号都是英文符号！如果你担心任何可能发生的错误，请在写完代码后按下`F5`键，在 IDLE 中运行一次你的代码。**
- - - -
### 目录
1. [ **Python 常用算法应用** ](/?id=_1-python-常用算法应用)
- 1.1 [枚举法](/?id=_11-枚举法)
- 1.2 [迭代法](/?id=_12-迭代法)
- 1.3 [递归法](/?id=_13-递归法)
- 1.4 [迭代与递归](/?id=_14-迭代与递归)
- 1.5 [ 二分法](/?id=_15- 二分法)
- - - -
### 1. Python 常用算法应用
- - - -
#### 1.1 枚举法
枚举法又称为穷举法，就是将问题所有可能的解逐个列举，然后根据条件判断此解是否符合要求，符合则保留，否则舍去。根据这个思想，可以 **用循环结构列举每个解并用 if 语句判断此解是否符合要求。**

例：输入 2 个整数 `a` 和`b`,输出它们所有的公约数,如 12 和 8 的公约数是 1，2，4。
```Python
a=int(input("输入整数 a:"))
b=int(input("输入整数 b:"))
c=min(a,b)
for i in range(1,c+1):
#从 1 枚举到 c
    if a%i==0 and b%i==0: 
    #判断 i 是否符合
        print(i,end=' ') 
        #符合要求打印出 i
```
?> **具体方法：** 在 `a` 和 `b` 中取最小的一个值赋给 `c`，则 `a` 和 `b` 所有的公约数在 [1，c] 区间，接下来逐个列举 [1，c] 区间里的每一个数 `i` 并判断 `i` 是否是 `a` 和 `b` 的公约数 ，即 `i` 要同时满足 `a%i==0`，`b%i==0`。

**总结：使用枚举算法解题的基本思路如下：**
1. 首先确定枚举对象、枚举范围。
2. 逐一枚举可能的解，利用判定条件验证每个解是否是问题的解。
- - - -
#### 1.2 迭代法
迭代法也称辗转法，是一类 **利用递推公式或循环算法不断用变量的旧值递推出新值来求问题的解或近似解的方法。**

例：已知一个数列：1、1、2、3、5、8、13、21…,它的第 1 项是 1，第 2 项是 1，第 3 项是 2，…,输入一个正整数 `n`(n>3),输出这个数列的第 `n` 项。

```Python
f1=1 
#初始值是数列的第 1 项
f2=1 
#初始值是数列的第 2 项
n=int(input("输入 n:"))
for i in range(3,n+1):
     ans=f1+f2 
     #推出数列第 i 项存入 ans
     f1=f2 
     #更新 f1
     f2=ans 
     #更新 f2，到此语句 f1,f2 为下一步推出第 i+1 项做好了准备
print(ans)
```
?> 这个数列是著名的斐波拉契数列，它的特点是数列的第 `i` 项是前 2 项之和。要求出第 `n` 项，由于第 1、2 项是已知的，可以根据第 1、2 项的值推出第 3 项的值，第 3 项值确定了，可以根据第 2、3 项的值推出第 4 项的值，以此类推，当推出第 `n-1` 项的值时，就可根据第 `n-2`、`n-1` 项来推出第 `n` 项值。

!> Python 语言中有对变量赋值的特殊写法，例如 f1,f2=f2,f1 就表示把表达式右边现有 f2 和 f1 的值分别赋给表达式左边的 f1 和 f2。用这种赋值方法上面的程序可这样改写:
```Python
for i in range(3,n+1):
    f1,f2=f2,f1+f2
print(f2)
```
**总结：利用迭代算法解决问题，需要做好以下三个方面的工作：**
1. **确定迭代变量**

这类问题中，至少存在一个直接或间接地不断由旧值递推出新值的变量，这个变量就是迭代变量。迭代变量在循环代码中参与运算的同时又保存当前结果，当前的结果作为下一次循环计算的初始值。

2. **建立迭代关系式**

所谓迭代关系式，指如何从变量的前一个值推出其下一个值的公式（或关系）。

3. **对迭代过程进行控制**

迭代过程的控制通常可分为两种情况：一种是所需的迭代次数是个确定的值，可以计算出来；另一种是所需的迭代次数无法确定。对于前一种情况，如求斐波拉契数列第 n 项，可以构建一个固定次数的循环来实现对迭代过程的控制；对于后一种情况，要进一步分析出结束迭代过程的条件。
- - - -
#### 1.3 递归法 
在程序设计中，把程序调用自身的编程技巧称为递归。

例：数学中用!符号表示阶乘，其定义是 `n!=1*2*3*…*(n-1)*n`, 输入一个正整数 `n`，输出 `n!`。根据定义，可用迭代的方法解决这个问题。
```Python
n=int(input("请输入整数 n:"))
s=1
for i in range(2,n+1):
    s=s*i
print(s)
```
除了上述方法，也可以从另外一个角度来思考，观察发现 `n!=n*(n-1)!`，如果`(n-1)!`是已知的，这个问题就解决了。比如求 `5`！，由于 `5！=5*4！`，要求 `5!`，只要求出 `4！`，同理由于 `4！=4*3！`，要求 `4!`只要求出 `3!`，以此类推，要求 `3!`只要求出 `2!`，要求 `2!`只要求出 `1!`，而 `1!`是已知的就等于 1。到此可以倒推回去，由于 `1!=1`，所以 有：

`2！=2*1！=2`

`3!=3*2!=3*2=6`

`4!=4*3!=4*6=24`

`5!=5*4!=5*24=120`

整个过程如图所示，其中 `f(n)`表示求` n!`的自定义函数：

![图片：递推过程](/递推过程.jpg)

按照这种方法，可以这样处理：
```Python
def f(n):
#自定义一个求 n!的函数 f
    if n==1: 
    #问题简单直接求解
        return 1 
        #当 n 等于 1 时，这个问题是已知的，返回结果 1
    else:
        return n*f(n-1) 
        #当 n>1 时,分解为(n-1)!子问题，返回结果 n*f(n-1)
n=int(input("请输入 n:"))
ans=f(n) 
#调用 f()函数，把结果给 ans
print(ans)
```
?> 这个函数中，代码分为两大部分：第一部分就是 `if` 语句，代表这个问题规模小到能直接给出解，如 `n!` 问题中当 `n` 为 1 时直接返回 `1！=1` 的这个结果，递归中能直接给出解的条件称之为边界条件。第二部分是 `else` 部分，代表当问题还没有小到边界条件时则继续划分成子问题，由于子问题的解法和原问题一样，只是规模缩小了，所以出现了调用相同函数的情况，就是自己调用了自己，只不过参数变小了，如调用参数为 `n` 的 `f()` 函数中出现了 `n*f(n-1)` 语句，就是调用参数为 `n-1` 的 `f()` 函数。

**总结：**

递归为解决问题提供了一种新的思路，可以通过把一个规模大的问题划分成若干规模较小的相同子问题，若子问题比较简单，则直接求解；否则，采用与原问题相同的方法对这些子问题进行再划分、求解，依次类推，直到子问题变得较为简单，可以直接求解，当求出所有子问题的解后再对其进行汇总即可得到原问题的解。特别需要注意的是当子问题足够小的时候必须有明确的解，就是问题必须有边界，例如 `1！=1`，否则问题会陷入无穷的调用之中。

- - - -
#### 1.4 迭代与递归
迭代和递归都是程序设计中解决问题的重要思想，许多程序既可用迭代的方式实现也可用递归的方法实现，如 n!和斐波拉契数列。

例：如何用递归法求 2 个数的最大公约数？
```Python
m,n=map(int,input().split())
def gcd(a,b):
    if a%b==0: 
         return b
    else:
         return gcd(b,a%b)
print(gcd(m,n))
```
?> 前面求 2 个数的最大公约数分别用了穷举法和迭代法，辗转相除过程中 `r=a%b`,如果 `r` 不等于 0，`a `和 `b` 的最大公约数就等于 `b` 和 `r` 的最大公约数，这其中就蕴含了递归的思想，即如果 `r!=0`,`a` 和 `b` 的最大公约数转化成了规模更小的 `b` 和 `r` 的最大公约数，边界条件是如果 `a%b==0` 则最大公约数就是 `b`。

**总结：**

代码结构上，递归虽是分支结构，但是通过重复调用函数自身实现了一种自动循环；迭代是函数内某段代码实现循环。分析问题思想上，递归是一种将大问题转化成小问题的思想；迭代是利用已知的变量值，根据递推公式不断演进得到变量新值的编程思想。很多问题上，例如斐波拉契数列，迭代和递归都用到了递推的方法，这样同一个问题即可用迭代也可用递归去实现。虽然递归能大大降低分析问题的难度和程序的代码量，但在调用自身过程中，随着调用层次的增加，效率会变得低下。
- - - -
#### 1.5  二分法
二分法是针对一定范围内所有有序的可能值，每次取其中间位置的值和答案进行比较来缩小查找范围，在新的范围内采取同样的方法直到找到问题的解的一种策略方法。

?> 例如生活中有这样的问题，某个商品的价格是 1-100 之间整数，请猜出该商品的价格。通常第一次会猜 1-100 中间那个数 50，这时只有三种情况发生：
- 猜对了，游戏结束；
- 猜高了，那么价格区间就一定在[1，49]之间，下次用同样的方法在[1，49]中猜；
- 猜低了，那么价格区间就一定在[51，100]之间，下次用同样的方法在[51，100]中猜；

二分法每次都猜中间的数是否符合要求，这样做的结果就是：要么猜中，游戏结束；要么没有猜中但将下次猜想的范围缩小一半。所以二分相对于顺序枚举来说，大大的提高了效率。
- - - -
_End._
